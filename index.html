<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jingooth Fusion Game</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --card: #ffffff;
      --txt: #222;
      --muted: #666;
      --accent: #7a9cff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans Thai', sans-serif;
      background: var(--bg);
      color: var(--txt);
      overflow: hidden;
    }
    header {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 14px;
      background: rgba(255, 255, 255, .8);
      backdrop-filter: blur(8px);
      z-index: 5;
      border-bottom: 1px solid #e9ebff;
    }
    .brand { font-weight: 700; }
    .hud { display: flex; gap: 12px; font-weight: 600; }
    .wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100svh;
      padding: 80px 12px 16px;
    }
    canvas {
      background: #eef1ff;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
      max-width: 100%;
      height: auto;
    }
    .panel {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(10,15,40,.5);
      z-index: 10;
    }
    .card {
      background: var(--card);
      width: min(720px, 92vw);
      border-radius: 18px;
      padding: 22px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      text-align: center;
    }
    .btn {
      padding: 12px 18px;
      border: none;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
    }
    .small { font-size: 12px; color: var(--muted); margin-top: 10px; }
    .tip { font-size: 13px; color: var(--muted); }
    footer {
      position: fixed;
      bottom: 8px;
      right: 12px;
      font-size: 14px;
      color: #7a9cff;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(255,255,255,0.8);
      font-family: 'Noto Sans Thai', system-ui, sans-serif;
      z-index: 20;
    }
  </style>
  <script defer src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
</head>
<body>
  <header>
    <div class="brand">üéÆ Jingooth Fusion Game</div>
    <div class="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Level: <span id="nextLevel">1</span></div>
    </div>
  </header>

  <div class="wrap">
    <canvas id="game" width="432" height="768"></canvas>
  </div>

  <div id="start" class="panel">
    <div class="card">
      <h1>Jingooth Fusion Game</h1>
      <p class="tip">‡πÅ‡∏ï‡∏∞/‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏ä‡∏¥‡πâ‡∏ô ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏£‡∏ß‡∏°‡∏ä‡∏¥‡πâ‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô üé≤</p>
      <p class="small">‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå <b>/images/face1.png ‚Ä¶ face12.png</b></p>
      <button class="btn" onclick="window.startGame()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>
    </div>
  </div>

  <footer>by: namaoi.sweet üíï</footer>

<script>
(() => {
  const IMG_COUNT = 12;
  const IMG_PATHS = Array.from({length: IMG_COUNT}, (_,i)=>`images/face${i+1}.png`);
  const canvas = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const nextEl = document.getElementById('nextLevel');

  let Engine, Render, World, Bodies, Body, Events, Composite;
  let engine, render;
  let world;
  let textures = [];
  let nextLevel = 1;
  let allowDrop = false;
  let dropX = canvas.width/2;
  let score = 0;
  let gameOver = false;

  function loadImages(paths){
    return Promise.all(paths.map(src=>new Promise((res,rej)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = rej;
      img.src = src;
    })));
  }

  function setupMatter(){
    Engine = Matter.Engine;
    Render = Matter.Render;
    World = Matter.World;
    Bodies = Matter.Bodies;
    Body = Matter.Body;
    Events = Matter.Events;
    Composite = Matter.Composite;

    engine = Engine.create();
    render = Render.create({
      canvas: canvas,
      engine: engine,
      options: { wireframes:false, background:'transparent' }
    });
    world = engine.world;

    const w = canvas.width, h = canvas.height;
    const thickness = 40;
    World.add(world, [
      Bodies.rectangle(w/2, h+thickness/2, w, thickness, { isStatic:true }),
      Bodies.rectangle(-thickness/2, h/2, thickness, h, { isStatic:true }),
      Bodies.rectangle(w+thickness/2, h/2, thickness, h, { isStatic:true })
    ]);

    const topSensor = Bodies.rectangle(w/2, 120, w-20, 10, { isStatic:true, isSensor:true, label:'topSensor' });
    World.add(world, topSensor);

    Events.on(engine, 'collisionStart', evt => {
      const pairs = evt.pairs;
      for(const p of pairs){
        const a = p.bodyA, b = p.bodyB;
        if(a.isSensor || b.isSensor) continue;
        if(a.custom && b.custom && a.custom.level === b.custom.level){
          const relSpeed = Math.hypot(a.velocity.x-b.velocity.x, a.velocity.y-b.velocity.y);
          if(relSpeed < 2){
            merge(a,b);
          }
        }
      }
    });

    Events.on(engine, 'collisionActive', evt => {
      for(const p of evt.pairs){
        const a = p.bodyA, b = p.bodyB;
        if((a.label==='topSensor' && b.custom) || (b.label==='topSensor' && a.custom)){
          gameOver = true;
          allowDrop = false;
          const panel = document.getElementById('start');
          panel.style.display='flex';
          panel.querySelector('h1').innerText = 'Game Over üí•';
          panel.querySelector('.tip').innerText = '‡πÅ‡∏ï‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á';
        }
      }
    });

    Render.run(render);
    const runner = Matter.Runner.create();
    Matter.Runner.run(runner, engine);
  }

  function addPiece(level, x=canvas.width/2){
    const r = 18 + level*6;
    const tex = textures[level-1];
    const body = Bodies.circle(x, 50, r, {
      restitution: 0.2,
      friction: 0.001,
      render: {
        sprite: { texture: tex.src, xScale: (r*2)/tex.width, yScale:(r*2)/tex.height }
      }
    });
    body.custom = { level };
    World.add(engine.world, body);
    return body;
  }

  function merge(a,b){
    const level = a.custom.level;
    const nx = (a.position.x + b.position.x)/2;
    const ny = (a.position.y + b.position.y)/2;
    World.remove(engine.world, a);
    World.remove(engine.world, b);
    if(level < IMG_COUNT){
      const c = addPiece(level+1, nx);
      Matter.Body.setPosition(c, {x:nx, y:ny});
      score += level*10;
    } else {
      score += level*25;
    }
    scoreEl.textContent = score;
  }

  function scheduleNextLevel(){
    const r = Math.random();
    if(r < .6) nextLevel = 1;
    else if(r < .85) nextLevel = 2;
    else if(r < .95) nextLevel = 3;
    else nextLevel = 4;
    nextEl.textContent = nextLevel;
  }

  function initControls(){
    canvas.addEventListener('mousemove', e=>{
      const rect = canvas.getBoundingClientRect();
      dropX = (e.clientX - rect.left) * (canvas.width/rect.width);
    });
    canvas.addEventListener('touchmove', e=>{
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      dropX = (t.clientX - rect.left) * (canvas.width/rect.width);
    }, {passive:true});

    const drop = ()=>{
      if(!allowDrop || gameOver) return;
      addPiece(nextLevel, Math.max(30, Math.min(canvas.width-30, dropX)));
      scheduleNextLevel();
    };
    canvas.addEventListener('click', drop);
    canvas.addEventListener('touchend', ()=>{ drop(); }, {passive:true});
  }

  async function boot(){
    textures = await loadImages(IMG_PATHS);
    setupMatter();
    initControls();
    scheduleNextLevel();
    allowDrop = true;
  }

  window.startGame = ()=>{
    document.getElementById('start').style.display='none';
    if(engine){
      const bodies = Matter.Composite.allBodies(engine.world);
      for(const b of bodies){
        if(!b.isStatic) Matter.World.remove(engine.world, b);
      }
      score = 0; scoreEl.textContent = '0';
      gameOver = false;
      scheduleNextLevel();
      allowDrop = true;
      return;
    }
    boot();
  };
})();
</script>
</body>
</html>
